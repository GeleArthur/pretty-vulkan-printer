#version 460
#pragma shader_stage(mesh)
#extension GL_EXT_mesh_shader: enable
#extension GL_EXT_shader_8bit_storage: enable


layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout (triangles) out;
layout (max_vertices = 64, max_primitives = 126) out;

struct Vertex {
    vec3 Position;
    vec2 TexCoord;
    vec3 Normal;
    vec3 Tangent;
};

struct Meshlet {
    uint VertexOffset;
    uint TriangleOffset;
    uint VertexCount;
    uint TriangleCount;
};

layout (set = 0, binding = 0) uniform SceneGlobals {
    mat4x4 camera_view;
    mat4x4 camera_projection;
    vec3 position;
} sceneInfo;

layout (std430, set = 1, binding = 0) readonly buffer MeshletIn {
    Meshlet Meshlets[];
};
layout (std140, set = 1, binding = 1) readonly buffer VertexIn {
    Vertex Vertices[];
};
layout (std430, set = 1, binding = 2) readonly buffer VertexIndicesIn {
    uint VertexIndices[];
};
layout (std430, set = 1, binding = 3) readonly buffer TriangleIndicesIn {
    uint8_t TriangleIndices[];
};

layout (push_constant) uniform PushConstant {
    mat4x4 model;
    uint diffuse_texture_index;
    uint normal_texture_index;
    uint metalness_texture_index;
} pc;

layout (location = 0) out vec3 vertexColor[];

#define AS_GROUP_SIZE 32
struct Payload {
    uint MeshletIndices[AS_GROUP_SIZE];
    bool visable[AS_GROUP_SIZE];
};

taskPayloadSharedEXT Payload payload;

uint hash(uint a)
{
    a = (a + 0x7ed55d16) + (a << 12);
    a = (a ^ 0xc761c23c) ^ (a >> 19);
    a = (a + 0x165667b1) + (a << 5);
    a = (a + 0xd3a2646c) ^ (a << 9);
    a = (a + 0xfd7046c5) + (a << 3);
    a = (a ^ 0xb55a4f09) ^ (a >> 16);
    return a;
}

void main()
{
    uint meshletIndex = payload.MeshletIndices[gl_WorkGroupID.x];

    //    uint index = gl_GlobalInvocationID.x;
    Meshlet m = Meshlets[meshletIndex];

    if (gl_LocalInvocationIndex == 0)
    {
        SetMeshOutputsEXT(m.VertexCount, m.TriangleCount);
    }

    if (gl_LocalInvocationID.x < m.TriangleCount) {
        gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x] = uvec3(
        TriangleIndices[m.TriangleOffset + (gl_LocalInvocationID.x * 3)],
        TriangleIndices[m.TriangleOffset + (gl_LocalInvocationID.x * 3) + 1],
        TriangleIndices[m.TriangleOffset + (gl_LocalInvocationID.x * 3) + 2]
        );
    }

    if (gl_LocalInvocationID.x < m.VertexCount) {
        uint vertexIndex = m.VertexOffset + gl_LocalInvocationID.x;
        vertexIndex = VertexIndices[vertexIndex];

        vec4 locatiomyes = sceneInfo.camera_projection * sceneInfo.camera_view * pc.model * vec4(Vertices[vertexIndex].Position, 1.0);

        gl_MeshVerticesEXT[gl_LocalInvocationID.x].gl_Position = locatiomyes;

        //        vec3 color = vec3(
        //        float(gl_WorkGroupID.x & 1),
        //        float(gl_WorkGroupID.x & 3) / 4,
        //        float(gl_WorkGroupID.x & 7) / 8);
        uint mhash = hash(gl_WorkGroupID.x);
        vertexColor[gl_LocalInvocationID.x] = vec3(float(mhash & 255), float((mhash >> 8) & 255), float((mhash >> 16) & 255)) / 255.0;

        //vertexColor[gl_LocalInvocationID.x] = color;
        //        vertexColor[gl_LocalInvocationID.x] = payload.visable[gl_WorkGroupID.x] ? vec3(0, 1, 0) : vec3(1, 0, 0);
    }

    //    gl_MeshVerticesEXT[gl_LocalInvocationID.x].gl_Position = vec4(1.0f);



    // Set up 3 vertices, 1 triangle
    //    const uint primitiveCount = 1;

    //    gl_PrimitiveCountNV = primitiveCount;

    // write indices for primitive 0
    //    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    //
    //    // vertex 0
    //    gl_MeshVerticesEXT[0].gl_Position = vec4(-0.5,  0.5, 0.0, 1.0);
    ////    gl_MeshVerticesEXT[0].Color    = vec3(1.0, 0.0, 0.0);
    ////
    ////    // vertex 1
    //    gl_MeshVerticesEXT[1].gl_Position = vec4( 0.5,  0.5, 0.0, 1.0);
    ////    gl_MeshVerticesEXT[1].Color    = vec3(0.0, 1.0, 0.0);
    ////
    ////    // vertex 2
    //    gl_MeshVerticesEXT[2].gl_Position = vec4( 0.0, -0.5, 0.0, 1.0);
    //    gl_MeshVerticesEXT[2].Color    = vec3(0.0, 0.0, 1.0);
}