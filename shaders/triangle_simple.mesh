#version 460
#pragma shader_stage(mesh)
#extension GL_EXT_mesh_shader: enable

layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout (triangles) out;
layout (max_vertices = 64, max_primitives = 128) out;

struct Vertex {
    vec3 Position;
    vec2 TexCoord;
    vec3 Normal;
    vec3 Tangent;
};

struct Meshlet {
    uint VertexOffset;
    uint TriangleOffset;
    uint VertexCount;
    uint TriangleCount;
};

layout (set = 0, binding = 0) uniform SceneGlobals {
    mat4x4 camera_view;
    mat4x4 camera_projection;
    vec3 position;
} sceneInfo;

layout (std430, set = 1, binding = 0) readonly buffer MeshletIn {
    Meshlet Meshlets[];
};
layout (std140, set = 1, binding = 1) readonly buffer VertexIn {
    Vertex Vertices[];
};
layout (std430, set = 1, binding = 2) readonly buffer VertexIndicesIn {
    uint VertexIndices[];
};
layout (std430, set = 1, binding = 3) readonly buffer TriangleIndicesIn {
    uint TriangleIndices[];
};

layout (push_constant) uniform PushConstant {
    mat4x4 model;
    uint diffuse_texture_index;
    uint normal_texture_index;
    uint metalness_texture_index;
} pc;

layout (location = 0) out vec3 vertexColor[];

#define AS_GROUP_SIZE 32
struct Payload {
    uint MeshletIndices[AS_GROUP_SIZE];
    bool visable[AS_GROUP_SIZE];
};

taskPayloadSharedEXT Payload payload;

void main()
{
    uint meshletIndex = payload.MeshletIndices[gl_WorkGroupID.x];

    //    uint index = gl_GlobalInvocationID.x;
    Meshlet m = Meshlets[meshletIndex];

    if (gl_LocalInvocationIndex == 0)
    {
        SetMeshOutputsEXT(m.VertexCount, m.TriangleCount);
    }

    if (gl_LocalInvocationID.x < m.TriangleCount) {
        //
        // meshopt stores the triangle offset in bytes since it stores the
        // triangle indices as 3 consecutive bytes.
        //
        // Since we repacked those 3 bytes to a 32-bit uint, our offset is now
        // aligned to 4 and we can easily grab it as a uint without any
        // additional offset math.
        //
        uint packed = TriangleIndices[m.TriangleOffset + gl_LocalInvocationID.x];
        uint vIdx0 = (packed >> 0) & 0xFF;
        uint vIdx1 = (packed >> 8) & 0xFF;
        uint vIdx2 = (packed >> 16) & 0xFF;
        gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x] = uvec3(vIdx0, vIdx1, vIdx2);
    }

    //    if (gl_LocalInvocationID.x == 1) {
    //    }

    if (gl_LocalInvocationID.x < m.VertexCount) {
        uint vertexIndex = m.VertexOffset + gl_LocalInvocationID.x;
        vertexIndex = VertexIndices[vertexIndex];

        vec4 locatiomyes = sceneInfo.camera_projection * sceneInfo.camera_view * pc.model * vec4(Vertices[vertexIndex].Position, 1.0);

        gl_MeshVerticesEXT[gl_LocalInvocationID.x].gl_Position = locatiomyes;

        vec3 color = vec3(
        float(gl_WorkGroupID.x & 1),
        float(gl_WorkGroupID.x & 3) / 4,
        float(gl_WorkGroupID.x & 7) / 8);

        vertexColor[gl_LocalInvocationID.x] = color;
        //        vertexColor[gl_LocalInvocationID.x] = payload.visable[gl_WorkGroupID.x] ? vec3(0, 1, 0) : vec3(1, 0, 0);
    }

    //    gl_MeshVerticesEXT[gl_LocalInvocationID.x].gl_Position = vec4(1.0f);



    // Set up 3 vertices, 1 triangle
    //    const uint primitiveCount = 1;

    //    gl_PrimitiveCountNV = primitiveCount;

    // write indices for primitive 0
    //    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    //
    //    // vertex 0
    //    gl_MeshVerticesEXT[0].gl_Position = vec4(-0.5,  0.5, 0.0, 1.0);
    ////    gl_MeshVerticesEXT[0].Color    = vec3(1.0, 0.0, 0.0);
    ////
    ////    // vertex 1
    //    gl_MeshVerticesEXT[1].gl_Position = vec4( 0.5,  0.5, 0.0, 1.0);
    ////    gl_MeshVerticesEXT[1].Color    = vec3(0.0, 1.0, 0.0);
    ////
    ////    // vertex 2
    //    gl_MeshVerticesEXT[2].gl_Position = vec4( 0.0, -0.5, 0.0, 1.0);
    //    gl_MeshVerticesEXT[2].Color    = vec3(0.0, 0.0, 1.0);
}