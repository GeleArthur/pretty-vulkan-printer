#version 450
#pragma shader_stage(mesh)
#extension GL_EXT_mesh_shader: enable

layout (triangles) out;
layout (max_vertices = 128, max_primitives = 128) out;
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

#include "world_binds.glsl"
#include "shared_structs.glsl"

layout (std430, set = 1, binding = 4) readonly buffer SphereBoundsIn {
    ConeBounds coneBoundsData[];
};

layout (push_constant) uniform PushConstant {
    mat4 model;
    uint diffuse_texture_index;
    uint normal_texture_index;
    uint metalness_texture_index;
} pc;

layout (location = 0) out vec4 color[];

const float PI = 3.14159265359;

void main()
{
    const uint segments = 32;
    if (gl_LocalInvocationIndex == 0)
    {
        SetMeshOutputsEXT(segments, segments);
    }

    vec3 scale = vec3(
    length(pc.model[0].xyz), // X axis scale
    length(pc.model[1].xyz), // Y axis scale
    length(pc.model[2].xyz)   // Z axis scale
    );
    float maxScale = max(max(scale.x, scale.y), scale.z);


    vec4 sphere = vec4(
    vec3(pc.model * vec4(coneBoundsData[gl_WorkGroupID.x].sphereBounds.xyz, 1.0f)),
    coneBoundsData[gl_WorkGroupID.x].sphereBounds.w * maxScale
    );

    vec3 forward = normalize(sceneInfo.position - sphere.xyz);
    vec3 right = normalize(cross(vec3(0, 1, 0), forward));
    vec3 up = cross(forward, right);

    uint idx = gl_LocalInvocationID.x;

    if (idx <= segments) {
        if (idx == 0) {
            // Center vertex
            gl_MeshVerticesEXT[idx].gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(sphere.xyz, 1.0);
        }
        else
        {
            // Circle perimeter vertices
            float angle = 2.0 * PI * float(idx - 1) / float(segments);

            float x = sphere.w * cos(angle);
            float y = sphere.w * sin(angle);

            // Transform to world space using billboard basis
            vec3 worldPos = sphere.xyz + right * x + up * y;

            vec4 clipPos = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(worldPos, 1.0);

            gl_MeshVerticesEXT[idx].gl_Position = clipPos;
        }

        color[idx] = VisibleFrustumCone(sphere) ? vec4(0.0, 1.0, 0.0, 0.1) : vec4(1.0, 0.0, 0.0, 0.1);
        //        color[idx] = vec4(1.0, 0.0, 0.0, 0.0);
    }

    if (idx < segments) {
        gl_PrimitiveTriangleIndicesEXT[idx] = uvec3(0, idx + 1, (idx + 1) % segments + 1);
    }




    //    gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * pc.model * vec4(inPosition, 1.0);
    //    color = inColor;
}
