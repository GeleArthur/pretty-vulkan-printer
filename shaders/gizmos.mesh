#version 450
#pragma shader_stage(vertex)

layout (triangles) out;
layout (max_vertices = 128, max_primitives = 128) out;

layout (set = 0, binding = 0) uniform SceneGlobals {
    mat4x4 camera_view;
    mat4x4 camera_projection;
    vec3 position;
} sceneInfo;

layout (std430, set = 1, binding = 0) readonly buffer SpheresBuffer {
    vec4 spheres[];
};

layout (location = 0) out vec4 color;

void main()
{
    const uint segments = 32;
    if (gl_LocalInvocationIndex == 0)
    {
        SetMeshOutputsEXT(segments, segments);
    }

    vec4 sphere = spheres[gl_WorkGroupID.x].xyzw; //????

    vec3 forward = normalize(position - sphere.xyz);
    vec3 right = normalize(cross(vec3(0, 1, 0), forward));
    vec3 up = cross(forward, right);

    uint idx = gl_LocalInvocationID.x;

    if (idx <= segments) {
        if (idx == 0) {
            // Center vertex
            gl_MeshVerticesEXT[0].gl_Position = sphere.xyz;
        } else {
            // Circle perimeter vertices
            float angle = 2.0 * PI * float(idx - 1) / float(segments);

            float x = sphere.w * cos(angle);
            float y = sphere.w * sin(angle);

            // Transform to world space using billboard basis
            vec3 worldPos = sphere.xyz + right * x + up * y;

            gl_MeshVerticesEXT[idx].gl_Position = worldPos;
        }

        vertexColor[idx] = vec4(1.0);
    }

    if (idx < segments) {
        gl_PrimitiveTriangleIndicesEXT[idx] = vec3(idx, idx + 1, idx + 2);
    }


    //    gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * pc.model * vec4(inPosition, 1.0);
    //    color = inColor;
}
