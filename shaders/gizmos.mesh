#version 450
#pragma shader_stage(mesh)
#extension GL_EXT_mesh_shader: enable

layout (triangles) out;
layout (max_vertices = 128, max_primitives = 128) out;
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct FrustumCone
{
    vec3 Tip;
    float Height;
    vec3 Direction;
    float Angle;
};


layout (set = 0, binding = 0) uniform SceneGlobals {
    mat4x4 camera_view;
    mat4x4 camera_projection;
    vec3 position;
    FrustumCone camera_frustom;
} sceneInfo;

//layout (std430, set = 1, binding = 0) readonly buffer SpheresBuffer {
//    vec4 spheres[];
//};

layout (std430, set = 1, binding = 4) readonly buffer SphereBoundsIn {
    vec4 spheres[];
};

layout (push_constant) uniform PushConstant {
    mat4 model;
    uint diffuse_texture_index;
    uint normal_texture_index;
    uint metalness_texture_index;
} pc;

layout (location = 0) out vec4 color[];

const float PI = 3.14159265359;

bool VisibleFrustumCone(vec4 sphere)
{
    // Cone and sphere are within intersectable range
    vec3 v0 = sphere.xyz - sceneInfo.camera_frustom.Tip;
    float d0 = dot(v0, sceneInfo.camera_frustom.Direction);
    bool i0 = (d0 <= (sceneInfo.camera_frustom.Height + sphere.w));

    float diff = dot(normalize(v0), sceneInfo.camera_frustom.Direction);
    bool inside = diff >= cos(sceneInfo.camera_frustom.Angle * 0.5f);

    //    float cs = cos(sceneInfo.camera_frustom.Angle * 0.5);
    //    float sn = sin(sceneInfo.camera_frustom.Angle * 0.5);
    //    float a = dot(v0, sceneInfo.camera_frustom.Direction);
    //    float b = a * sn / cs;
    //    float c = sqrt(dot(v0, v0) - (a * a));
    //    float d = c - b;
    //    float e = d * cs;
    //    bool i1 = (e < sphere.w);

    return i0 && inside;// && i1;
}


void main()
{
    const uint segments = 32;
    if (gl_LocalInvocationIndex == 0)
    {
        SetMeshOutputsEXT(segments, segments);
    }

    vec4 sphere = vec4(vec3(pc.model * vec4(spheres[gl_WorkGroupID.x].xyz, 1.0f)), spheres[gl_WorkGroupID.x].w);

    vec3 forward = normalize(sceneInfo.position - sphere.xyz);
    vec3 right = normalize(cross(vec3(0, 1, 0), forward));
    vec3 up = cross(forward, right);

    uint idx = gl_LocalInvocationID.x;

    if (idx <= segments) {
        if (idx == 0) {
            // Center vertex
            gl_MeshVerticesEXT[idx].gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(sphere.xyz, 1.0);
        }
        else
        {
            // Circle perimeter vertices
            float angle = 2.0 * PI * float(idx - 1) / float(segments);

            float x = sphere.w * cos(angle);
            float y = sphere.w * sin(angle);

            // Transform to world space using billboard basis
            vec3 worldPos = sphere.xyz + right * x + up * y;

            vec4 clipPos = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(worldPos, 1.0);

            gl_MeshVerticesEXT[idx].gl_Position = clipPos;
        }

        color[idx] = VisibleFrustumCone(sphere) ? vec4(0.0, 1.0, 0.0, 0.1) : vec4(1.0, 0.0, 0.0, 0.1);
        //        color[idx] = vec4(1.0, 0.0, 0.0, 0.0);
    }

    if (idx < segments) {
        gl_PrimitiveTriangleIndicesEXT[idx] = uvec3(0, idx + 1, (idx + 1) % segments + 1);
    }




    //    gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * pc.model * vec4(inPosition, 1.0);
    //    color = inColor;
}
