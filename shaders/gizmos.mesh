#version 450
#pragma shader_stage(mesh)
#extension GL_EXT_mesh_shader: enable
#extension GL_EXT_buffer_reference: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_GOOGLE_include_directive: require

layout (triangles) out;
layout (max_vertices = 128, max_primitives = 128) out;
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

#include "world_binds.glsl"
#include "shared_structs.glsl"

layout (std430, set = 1, binding = 4) readonly buffer SphereBoundsIn {
    ConeBounds coneBoundsData[];
};

layout (push_constant) uniform PushConstant {
    mat4 model;
    uint diffuse_texture_index;
    uint normal_texture_index;
    uint metalness_texture_index;
} pc;

layout (location = 0) out vec4 color[];

const float PI = 3.14159265359;

void main()
{
    const uint segments = 32;
    if (gl_LocalInvocationIndex == 0)
    {
        SetMeshOutputsEXT(segments, segments);
    }

    ConeBounds cone = TransformCone(coneBoundsData[gl_WorkGroupID.x], pc.model);

    vec3 forward = normalize(sceneInfo.position - cone.sphere_bounds.xyz);
    vec3 right = normalize(cross(vec3(0, 1, 0), forward));
    vec3 up = cross(forward, right);

    uint idx = gl_LocalInvocationID.x;

    if (idx <= segments) {
        if (idx == 0) {
            // Center vertex
            gl_MeshVerticesEXT[idx].gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(cone.sphere_bounds.xyz, 1.0);
        }
        else
        {
            // Circle perimeter vertices
            float angle = 2.0 * PI * float(idx - 1) / float(segments);

            float x = cone.sphere_bounds.w * cos(angle);
            float y = cone.sphere_bounds.w * sin(angle);

            // Transform to world space using billboard basis
            vec3 worldPos = cone.sphere_bounds.xyz + right * x + up * y;

            vec4 clipPos = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(worldPos, 1.0);

            gl_MeshVerticesEXT[idx].gl_Position = clipPos;
        }

        color[idx] = IsVisible(cone) ? vec4(0.0, 1.0, 0.0, 0.1) : vec4(1.0, 0.0, 0.0, 0.1);
        //        color[idx] = vec4(1.0, 0.0, 0.0, 0.0);
    }

    if (idx < segments) {
        gl_PrimitiveTriangleIndicesEXT[idx] = uvec3(0, idx + 1, (idx + 1) % segments + 1);
    }




    //    gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * pc.model * vec4(inPosition, 1.0);
    //    color = inColor;
}
