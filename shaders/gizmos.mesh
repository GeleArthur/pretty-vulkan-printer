#version 450
#pragma shader_stage(mesh)
#extension GL_EXT_mesh_shader: enable

layout (triangles) out;
layout (max_vertices = 128, max_primitives = 128) out;
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0) uniform SceneGlobals {
    mat4x4 camera_view;
    mat4x4 camera_projection;
    vec3 position;
} sceneInfo;

layout (std430, set = 1, binding = 0) readonly buffer SpheresBuffer {
    vec4 spheres[];
};

layout (location = 0) out vec4 color[];

const float PI = 3.14159265359;

void main()
{
    const uint segments = 32;
    if (gl_LocalInvocationIndex == 0)
    {
        SetMeshOutputsEXT(segments, segments);
    }

    vec4 sphere = spheres[gl_WorkGroupID.x]; //????

    vec3 forward = normalize(sceneInfo.position - sphere.xyz);
    vec3 right = normalize(cross(vec3(0, 1, 0), forward));
    vec3 up = cross(forward, right);

    uint idx = gl_LocalInvocationID.x;

    if (idx <= segments) {
        if (idx == 0) {
            // Center vertex
            gl_MeshVerticesEXT[idx].gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(sphere.xyz,1.0);
        }
        else
        {
            // Circle perimeter vertices
            float angle = 2.0 * PI * float(idx - 1) / float(segments);

            float x = sphere.w * cos(angle);
            float y = sphere.w * sin(angle);

            // Transform to world space using billboard basis
            vec3 worldPos = sphere.xyz + right * x + up * y;

            vec4 clipPos = sceneInfo.camera_projection * sceneInfo.camera_view * vec4(worldPos, 1.0);

            gl_MeshVerticesEXT[idx].gl_Position = clipPos;
        }

        color[idx] = vec4(0.1, 0.1, 0.1, 1.0);
    }

    if (idx < segments) {
        gl_PrimitiveTriangleIndicesEXT[idx] = uvec3(0, idx+1, (idx + 1) % segments + 1);
    }




    //    gl_Position = sceneInfo.camera_projection * sceneInfo.camera_view * pc.model * vec4(inPosition, 1.0);
    //    color = inColor;
}
